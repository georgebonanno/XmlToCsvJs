<xhtml>

    <head>
        <style>
            .title {
                font-size: larger;
                font-weight: bold;
            }

            body {
                font-size: large;
            }

            .success {
                color: blue;
            }

            .error {
                color: red;
            }
        </style>
        <title>Xml to Csv Convertor</title>
        <div class="title">
            Xml to Csv
        </div>
    </head>

    <body>
        <div>
            step 1. Choose Xml file to convert to csv:
            <input type='file' accept='*.xml' onchange='openFile(event)'><br>
        </div>
        <div style="visibility: hidden;" id="step2">
            step 2. insert the nodes which should be converted to csv:
            <input type="text" id="tagNameInput" value="" onkeyup="checkNodeInput(this)" />
            <input type="submit" id="convertBtn" value="convert" disabled="true" onclick="saveTabDataToCsv()" />
        </div>
        <div style="visibility: hidden;" id="messageDiv" class="">

        </div>
        <script>

            var tableData;

            function notifyAndThrow(e) {
                notify(`conversion failed. please check logs: ${e.message}`, false);
                console.log(e.stack);
                throw e;
            }

            function notify(message, success = true) {
                var messageDiv = document.getElementById('messageDiv');
                messageDiv.style.visibility="visible";
                messageDiv.innerText = message;
                var outComeClass = success ? "success" : "error";
                messageDiv.classList.add(outComeClass);
            }

            function nodeToRow(node, fieldNames = {}, rowData = {}, path = "") {
                var elemRep = {};
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    var postFix;
                    if (!elemRep[child.tagName]) {
                        elemRep[child.tagName] = 1
                        postFix = ""
                    } else {
                        elemRep[child.tagName]++;
                        postFix = "_" + elemRep[child.tagName];
                    }
                    var isLeaf = child.children.length == 0;
                    var prefix = path.length > 0 ? path + "/" : "";
                    var fieldName = prefix + child.tagName + postFix;
                    if (isLeaf) {
                        rowData[fieldName] = child.innerHTML;
                        fieldNames[fieldName] = 1;
                    } else {
                        nodeToRow(child, fieldNames, rowData, fieldName)
                    }
                }
                return rowData;
            }

            function evalXpath(xmlDoc, xpathExpression) {
                console.log(`evaluating xpath expression ${xpathExpression}`)
                var nsResolver = xmlDoc.createNSResolver(xmlDoc.ownerDocument == null ? xmlDoc.documentElement : xmlDoc.ownerDocument.documentElement);
                var res = xmlDoc.evaluate(xpathExpression, xmlDoc, nsResolver, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null)
                return res;
            }

            function extractAllTagNames(xmlDoc, path = "", tagNames = {}) {
                for (var i = 0; i < xmlDoc.children.length; i++) {
                    var currentChild = xmlDoc.children[i];
                    var fullPath = path + "/" + currentChild.tagName;
                    tagNames[fullPath] = 1;
                    for (var ii = 0; ii < currentChild.children.length; ii++) {
                        extractAllTagNames(currentChild, fullPath, tagNames)
                    }
                }
                return tagNames;
            }

            function xmlStrToDoc(xmlStr) {
                var parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlStr, 'text/xml')
                return xmlDoc;
            }

            function convertToCsv(xmlDoc, tagName) {
                console.log("xml: ${xmlDoc} ", xmlDoc);
                var xpathExpression;
                if (!tagName.startsWith("/")) {
                    xpathExpression = "//" + tagName;
                } else {
                    xpathExpression = tagName;
                }
                var res = evalXpath(xmlDoc, xpathExpression)
                var nextNode;
                var tabData = [];
                console.log(`iterating transaction: ${res}`)
                var fieldNames = {};
                while (nextNode = res.iterateNext()) {
                    console.log("in row")
                    var rowData = nodeToRow(nextNode, fieldNames);
                    console.log(`storing data: ${rowData.internal_ref_number_2}`);
                    tabData.push(rowData);
                }
                return {
                    tabData: tabData,
                    fieldNames: fieldNames
                }
            }

            function openFile(event) {
                loadTextFile(event.target.files[0], xmlStr => {
                    try {
                        document.getElementById('messageDiv').style.visibility="hidden";
                        xmlDoc = xmlStrToDoc(xmlStr)
                        var step2Div = document.getElementById('step2');
                        step2Div.style.visibility = "visible";
                    } catch (e) {
                        notifyAndThrow(e);
                    }
                })
            }

            function rowToCommaSepString(fieldNames, row) {
                var rowCsv = "";
                for (var field in fieldNames) {
                    var strValue = row[field] ? row[field] : "";
                    rowCsv = rowCsv + strValue + ",";
                }
                return rowCsv;
            }

            function fieldNamesToCsv(fieldNames) {
                var rowCsv = "";
                for (var field in fieldNames) {
                    rowCsv = rowCsv + field + ",";
                }
                return rowCsv;
            }

            function download(filename, text) {
                var element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }

            

            function saveTabDataToCsv() {
                try {
                    var tagNameInput = document.getElementById('tagNameInput');
                    var tagName = tagNameInput.value;
                    tableData = convertToCsv(xmlDoc, tagName);
                    var fieldNamesStr = fieldNamesToCsv(tableData.fieldNames);
                    console.log(fieldNamesStr);
                    var csv = fieldNamesStr;
                    tableData.tabData.forEach(row => csv += "\n" + rowToCommaSepString(tableData.fieldNames, row));
                    download("row_data.csv", csv)
                    notify("conversion complete!");
                } catch (e) {
                    notifyAndThrow(e);
                }
            }


            function loadTextFile(path, onFileRead) {

                let reader = new FileReader();
                console.log("loading file from", path)

                reader.onload = (e) => {
                    const file = e.target.result;

                    // This is a regular expression to identify carriage  
                    // Returns and line breaks 
                    onFileRead(file);

                };

                reader.onerror = (e) => alert(e.target.error.name);

                reader.readAsText(path);
            }

            function checkNodeInput(inputElem) {
                if (inputElem.value.length > 0) {
                    var convertBtn = document.getElementById('convertBtn');
                    convertBtn.disabled = false;
                }
            }



        </script>
    </body>
</xhtml>