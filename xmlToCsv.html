<xhtml>

    <head>
        Xml to Csv 
        <div>
            step 1. Choose Xml file to convert to csv:
            <input type='file' accept='*.xml' onchange='openFile(event)'><br>
        </div>
        <div style="visibility: hidden;" id="step2">
            step 2. insert the nodes which should be converted to csv:
            <input type="text" id="tagNameInput" value="" onkeyup="checkNodeInput(this)"/>
            <input type="submit" id="convertBtn" value="convert" disabled="true" onclick="saveTabDataToCsv()"/>
        </div>
        
    </head>

    <body>
        <script>

            var tableData;

            function nodeToRow(node, fieldNames = {}, rowData = {}, path = "") {
                var elemRep={};
                for (var i = 0; i < node.children.length; i++) {
                    var child = node.children[i];
                    var postFix;
                    if (!elemRep[child.tagName]) {
                        elemRep[child.tagName]=1
                        postFix = ""
                    } else {
                        elemRep[child.tagName]++;
                        postFix = "_"+elemRep[child.tagName];
                    }
                    var isLeaf = child.children.length == 0;
                    var prefix = path.length > 0 ? path + "/" : "";
                    var fieldName=prefix+child.tagName+postFix;
                    if (isLeaf) {
                        rowData[fieldName] = child.innerHTML;
                        fieldNames[fieldName] = 1;
                    } else {
                        nodeToRow(child, fieldNames, rowData, fieldName)
                    }
                }
                return rowData;
            }

            function evalXpath(xmlDoc,xpathExpression) {
                console.log(`evaluating xpath expression ${xpathExpression}`)
                var nsResolver = xmlDoc.createNSResolver(xmlDoc.ownerDocument == null ? xmlDoc.documentElement : xmlDoc.ownerDocument.documentElement);
                var res = xmlDoc.evaluate(xpathExpression, xmlDoc, nsResolver, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null)
                return res;
            }

            function extractAllTagNames(xmlDoc,path="",tagNames={}) {
                for (var i=0; i<xmlDoc.children.length; i++) {
                    var currentChild = xmlDoc.children[i];
                    var fullPath=path+"/"+currentChild.tagName;
                    tagNames[fullPath]=1;
                    for (var ii=0; ii<currentChild.children.length; ii++) {
                        extractAllTagNames(currentChild,fullPath,tagNames)
                    }
                }
                return tagNames;
            }

            function xmlStrToDoc(xmlStr) {
                var parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlStr, 'text/xml')
                return xmlDoc;
            }

            function convertToCsv(xmlDoc, tagName) {
                console.log("xml: ${xmlDoc} ", xmlDoc);
                var xpathExpression;
                if (!tagName.startsWith("/")) {
                    xpathExpression="//"+tagName;
                } else {
                    xpathExpression=tagName;
                }
                var res=evalXpath(xmlDoc,xpathExpression)
                var nextNode;
                var tabData = [];
                console.log(`iterating transaction: ${res}`)
                var fieldNames = {};
                while (nextNode = res.iterateNext()) {
                    console.log("in row")
                    var rowData = nodeToRow(nextNode, fieldNames);
                    console.log(`storing data: ${rowData.internal_ref_number_2}`);
                    tabData.push(rowData);
                }
                return {
                    tabData: tabData,
                    fieldNames: fieldNames
                }
            }

            function openFile(event) {
                loadTextFile(event.target.files[0], xmlStr => {
                    xmlDoc = xmlStrToDoc(xmlStr)
                    var step2Div=document.getElementById('step2');
                    step2Div.style.visibility="visible";
                })
            }

            function rowToCommaSepString(fieldNames, row) {
                var rowCsv = "";
                for (var field in fieldNames) {
                    var strValue = row[field] ? row[field] : "";
                    rowCsv = rowCsv + strValue + ",";
                }
                return rowCsv;
            }

            function fieldNamesToCsv(fieldNames) {
                var rowCsv = "";
                for (var field in fieldNames) {
                    rowCsv = rowCsv + field + ",";
                }
                return rowCsv;
            }

            function download(filename, text) {
                var element = document.createElement('a');
                element.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
                element.setAttribute('download', filename);

                element.style.display = 'none';
                document.body.appendChild(element);

                element.click();

                document.body.removeChild(element);
            }
            
            function saveTabDataToCsv() {
                var tagNameInput=document.getElementById('tagNameInput');
                var tagName=tagNameInput.value;
                tableData = convertToCsv(xmlDoc, tagName);
                var fieldNamesStr = fieldNamesToCsv(tableData.fieldNames);
                console.log(fieldNamesStr);
                var csv = fieldNamesStr;
                tableData.tabData.forEach(row => csv+="\n"+rowToCommaSepString(tableData.fieldNames, row));
                download("row_data.csv",csv)
            }
            

            function loadTextFile(path, onFileRead) {

                let reader = new FileReader();
                console.log("loading file from", path)

                reader.onload = (e) => {
                    const file = e.target.result;

                    // This is a regular expression to identify carriage  
                    // Returns and line breaks 
                    onFileRead(file);

                };

                reader.onerror = (e) => alert(e.target.error.name);

                reader.readAsText(path);
            }

            function checkNodeInput(inputElem) {
                if (inputElem.value.length > 0) {
                    var convertBtn = document.getElementById('convertBtn');
                    convertBtn.disabled=false;
                }
            }



        </script>
    </body>
</xhtml>